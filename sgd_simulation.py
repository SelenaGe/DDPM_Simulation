# -*- coding: utf-8 -*-
"""SGD_simulation.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/13YUDB5Sj6TcrBW-oM_56qwC0HqbLHt1l
"""

import matplotlib.pyplot as plt
import numpy as np
import random

class least_square():
    def __init__(self,t:int,gamma:float,gamma_on_iteration:bool,theta:list,theta_star:list,sigma:float) -> None:
        self.t = t
        self.gamma = gamma
        self.on_iteration = gamma_on_iteration
        self.theta = theta
        self.theta_star = theta_star
        self.sigma = sigma
        self.temp_step = 0
        self.data = []
        self.err = []
        self.theta_1 = []
        self.theta_2 = []

    def generate_data(self):
        for _ in range (self.t):
            piece_data = []
            y = 0
            for dimension in self.theta_star:
                x = random.random()*5 #assume the x is scatter in range (0,5)
                piece_data.append(x)
                y = y + x * dimension
            y = y + random.gauss(0,self.sigma) #y = \theta^* \cdot x + \xi where \xi ~ N(0,\sigma)
            self.data.append([piece_data,y])
        print("finish generating %d pieces of data" %(self.t))

    def _inner_product(self,x1:list,x2:list) -> float:   # np.dot(x1,x2) is better.
        if(len(x1)!=len(x2)):
            print("dimension not match with the first %d,and the second %d" %(len(x1),len(x2)))
        else:
            result = 0
            result = np.dot(x1,x2)
        return result

    def _2_norm(self,x1:list,x2:list) -> float: # 0.5 * np.linalg.norm(x1 - x2)
        if(len(x1)!=len(x2)):
            print("dimension not match with the first %d,and the second %d" %(len(x1),len(x2)))
        else:
            result = 0
            # print(x1)
            # print(x2)
            # print(x1-x2)
            result = 0.5 * np.linalg.norm(x1-x2) #Check if there is a square missing
            # print(result)
            return result

    def _update_theta(self,coefficient:float,x:list):
        for i in range(len(self.theta)):
            self.theta[i] = self.theta[i] - coefficient * x[i]

    def iter(self):
        if(self.on_iteration):
            for i in range (self.t):
                x = self.data[i][0]
                y = self.data[i][1]
                product = self._inner_product(theta,x)
                coefficient = 2 * self.gamma/(i+1) * (product - y)
                self._update_theta(coefficient,x)
                self.err.append(self._2_norm(theta,theta_star))
                self.theta_1.append(self.theta[0])
                self.theta_2.append(self.theta[1])

        else:
            for piece in self.data:
                x = piece[0]
                y = piece[1]
                #theta_{t+1} = theta_t - 2gamma(<theta_t,x_t>-y_t)x_t, in particular, 2 is always ignored.
                product = self._inner_product(theta,x)
                coefficient = 2 * self.gamma * (product - y)
                self._update_theta(coefficient,x)
                self.err.append(self._2_norm(theta,theta_star))
                self.theta_1.append(self.theta[0])
                self.theta_2.append(self.theta[1])
                #print(coefficient)
                #print(theta)


    def show_err(self):
        plt.plot(self.err)
        plt.show()

    def show_theta1(self):
        theta_1_star = [self.theta_star[0] for _ in range(self.t)]
        plt.plot(self.theta_1)
        plt.plot(theta_1_star)
        plt.show()

    def show_theta2(self):
        theta_2_star = [self.theta_star[1] for _ in range(self.t)]
        plt.plot(self.theta_2)
        plt.plot(theta_2_star)
        plt.show()


#(i) and (ii)
if __name__ == '__main__':
    theta = np.zeros(5) #[0. ,0. ,0.,0. ,0.]
    theta_star = [0.1,-0.2,1,0.5,-0.5]
    my_ls = least_square(1000,0.01,False,theta,theta_star,0.1)
    my_ls.generate_data()
    print(len(my_ls.data)) #1000
    my_ls.iter()
    print(my_ls.theta)
    my_ls.show_err()
    my_ls.show_theta1()
    my_ls.show_theta2()

#(iii) change to 1: it fluctuates more
if __name__ == '__main__':
    theta = np.zeros(5)
    theta_star = [0.1,-0.2,1,0.5,-0.5]
    my_ls = least_square(1000,0.01,False,theta,theta_star,1)
    my_ls.generate_data()
    print(len(my_ls.data)) #1000
    my_ls.iter()
    print(my_ls.theta)
    my_ls.show_err()
    my_ls.show_theta1()
    my_ls.show_theta2()

#(iii) change to 3: it fluctuates more and more
if __name__ == '__main__':
    theta = np.zeros(5)
    theta_star = [0.1,-0.2,1,0.5,-0.5]
    my_ls = least_square(1000,0.01,False,theta,theta_star,3)
    my_ls.generate_data()
    print(len(my_ls.data)) #1000
    my_ls.iter()
    print(my_ls.theta)
    my_ls.show_err()
    my_ls.show_theta1()
    my_ls.show_theta2()

#(iv) change to 10 times bigger: it explodes
if __name__ == '__main__':
    theta = np.zeros(5)
    theta_star = [0.1,-0.2,1,0.5,-0.5]
    my_ls = least_square(1000,0.1,False,theta,theta_star,0.1)
    my_ls.generate_data()
    print(len(my_ls.data)) #1000
    my_ls.iter()
    print(my_ls.theta)
    my_ls.show_err()
    my_ls.show_theta1()
    my_ls.show_theta2()

#(iv) change to 10 times smaller: it moves slowly
if __name__ == '__main__':
    theta = np.zeros(5)
    theta_star = [0.1,-0.2,1,0.5,-0.5]
    my_ls = least_square(1000,0.001,False,theta,theta_star,0.1)
    my_ls.generate_data()
    print(len(my_ls.data)) #1000
    my_ls.iter()
    print(my_ls.theta)
    my_ls.show_err()
    my_ls.show_theta1()
    my_ls.show_theta2()

#(v)
if __name__ == '__main__':
    theta = np.zeros(5)
    theta_star = [0.1,-0.2,1,0.5,-0.5]
    my_ls = least_square(1000,0.5,True,theta,theta_star,0.1)
    my_ls.generate_data()
    print(len(my_ls.data)) #1000
    my_ls.iter()
    print(my_ls.theta)
    my_ls.show_err()
    my_ls.show_theta1()
    my_ls.show_theta2()

